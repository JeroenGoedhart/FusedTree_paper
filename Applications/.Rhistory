pvals[is.na(pvals)]<-1
print("Estimated p values in the nodes are:")
print(pvals)
print("Remove omics effects in nodes in order:")
pvals<-sort(pvals,decreasing = T)
print(paste(names(pvals),collapse = " -> "))
Dat = Dat_Tree(tree = Treefit, X = X, Y = Y,Z = Z,  LinVars = Lin,model = "surv")
X1 = Dat$Omics; Y1 = Dat$Response; U1 = Dat$Clinical
colSums(U1)
Dat_tree_test = Dat_Tree(tree=Treefit, X=Xtest, Y=Ytest, Z=Ztest, LinVars = Lin,model = "surv")
Ute_tree = Dat_tree_test$Clinical; Yte_tree=Dat_tree_test$Response; Xte_tree = Dat_tree_test$Omics
remove(Dat,Dat_tree_test,Yte_tree)
colSums(Ute_tree)
Concordances <- c()
Concordances1 <- c()
AUCs <- c()
j=1
EmpNodes = names(pvals)[1:j]
#names(Fits)[i] <- paste(names(pvals)[1:i],collapse = ",")
print(paste("Fit FusedTree without omics effects in", paste(names(pvals)[1:j],collapse = ", ")))
ids = lapply(EmpNodes, function (x) grepl(x,colnames(X1)))
ids1 = which(Reduce("|",ids))
X2 <- X1[,-ids1]
Xte <- Xte_tree[,-ids1]
remove(ids,ids1)
NodNum <- ncol(X2)/p
dim(X2)
gc()
if (NodNum == 0){
Fit <- glm(Y1 ~ 0 + ., data = data.frame(U1),family = "binomial")$coefficients
ids = which(names(Fit) %in% colnames(Ute_tree))
Ests = Fit[ids]
LP <- as.numeric(Ute_tree %*% Ests)
Preds <- exp(LP)/(1+exp(LP))
AUCs[j] <- roc(Yte_tree,Preds)$auc
MSEs[j] <- mean((Preds-Yte_tree)^2)
remove(Fit,ids)
}
if (NodNum == 1){
dim(X2)
Lam <- optPenaltyGLM.kCVauto2(Y = Y1, X = X2, U = U1,
lambdaInit = Lam1, lambdaGinit = 0, Dg = matrix(0, ncol=ncol(X2), nrow = ncol(X2)),
folds = foldsHyp,
model = "surv", loss="loglik")
Fit <-ridgeGLM2(Y = Y1, U = U1, X = X2,
lambda = Lam, lambdaG = 0, Dg = matrix(0, ncol=ncol(X2), nrow = ncol(X2)),
model="surv")
names(Fit)<-c(colnames(U1),colnames(X2))
#exp(Fit[1:5])/(1+exp(Fit[1:5]))
#head(Fit,50)
#ids1 = which(colnames(Xte) %in% names(Fit))
#Xte <- Xte[,ids1]
#ids = which(names(Fit) %in% c(colnames(Ute_tree), colnames(Xte)))
#Ests = Fit[ids]
#Ests = Fit
#remove(ids1,ids,Lam)
LP = -as.numeric(cbind(Ute_tree,Xte) %*% Fit)
Preds <- exp(LP)/(1+exp(LP))
Concordances[j] <- concordance(Yte_tree ~ LP)$concordance
remove(Fit,LP,Preds)
}
if (NodNum > 1){
Delta = .PenMatr(NumNodes = NodNum, p = p)
dim(Delta)
dim(X2)
if (ncol(Delta) != ncol(X2)){stop("number of columns of penalty matrix does not equal number of columns of design matrix X")}
#if(lambdaInit <= 0){stop("initial penalty lambdaInit should be larger than zero")}
#if(alphaInit <= 0){stop("initial penalty alphaInit should be larger than zero")}
optPenalties <- optPenaltyGLM.kCVauto2(Y = Y1, X = X2, U = U1,
lambdaInit = optLam1[1], lambdaGinit = 1000,
folds = foldsHyp,
Dg=Delta,model = "surv",loss="loglik")
optPenalties
optLam1
Fit = ridgeGLM2(Y = Y1, U = U1, X = X2,
lambda = optPenalties[1], lambdaG = optPenalties[2], Dg = Delta,
model="surv")
names(Fit)<-c(colnames(U1),colnames(X2))
#ids1 = which(colnames(Xte) %in% names(Fit))
#Xte <- Xte[,ids1]
#ids = which(names(Fit) %in% c(colnames(Ute_tree), colnames(Xte)))
#Ests = Fit[ids]
#Ests = Fit
#exp(Ests)[1:5]/(1+exp(Ests)[1:5])
LP = -as.numeric(cbind(Ute_tree,Xte) %*% Fit)
#exp(LP)[1:5]/(1+exp(LP)[1:5])
Concordances[j] <- concordance(Ytest ~ LP)$concordance
Concordances1[j] <- Est.Cval(cbind(Ytest[,1],Ytest[,2],-LP), tau=5, nofit=T)$Dhat
AUCs[j] <- survivalROC.C(Stime = Ytest[,1], status = Ytest[,2], marker = -LP, predict.time = RelTime)$AUC
remove(Fit,ids)
}
j=1
EmpNodes = names(pvals)[1:j]
#names(Fits)[i] <- paste(names(pvals)[1:i],collapse = ",")
print(paste("Fit FusedTree without omics effects in", paste(names(pvals)[1:j],collapse = ", ")))
ids = lapply(EmpNodes, function (x) grepl(x,colnames(X1)))
ids1 = which(Reduce("|",ids))
X2 <- X1[,-ids1]
Xte <- Xte_tree[,-ids1]
remove(ids,ids1)
NodNum <- ncol(X2)/p
dim(X2)
gc()
if (NodNum == 0){
Fit <- glm(Y1 ~ 0 + ., data = data.frame(U1),family = "binomial")$coefficients
ids = which(names(Fit) %in% colnames(Ute_tree))
Ests = Fit[ids]
LP <- as.numeric(Ute_tree %*% Ests)
Preds <- exp(LP)/(1+exp(LP))
AUCs[j] <- roc(Yte_tree,Preds)$auc
MSEs[j] <- mean((Preds-Yte_tree)^2)
remove(Fit,ids)
}
if (NodNum == 1){
dim(X2)
Lam <- optPenaltyGLM.kCVauto2(Y = Y1, X = X2, U = U1,
lambdaInit = Lam1, lambdaGinit = 0, Dg = matrix(0, ncol=ncol(X2), nrow = ncol(X2)),
folds = foldsHyp,
model = "surv", loss="loglik")
Fit <-ridgeGLM2(Y = Y1, U = U1, X = X2,
lambda = Lam, lambdaG = 0, Dg = matrix(0, ncol=ncol(X2), nrow = ncol(X2)),
model="surv")
names(Fit)<-c(colnames(U1),colnames(X2))
#exp(Fit[1:5])/(1+exp(Fit[1:5]))
#head(Fit,50)
#ids1 = which(colnames(Xte) %in% names(Fit))
#Xte <- Xte[,ids1]
#ids = which(names(Fit) %in% c(colnames(Ute_tree), colnames(Xte)))
#Ests = Fit[ids]
#Ests = Fit
#remove(ids1,ids,Lam)
LP = -as.numeric(cbind(Ute_tree,Xte) %*% Fit)
Preds <- exp(LP)/(1+exp(LP))
Concordances[j] <- concordance(Yte_tree ~ LP)$concordance
remove(Fit,LP,Preds)
}
if (NodNum > 1){
Delta = .PenMatr(NumNodes = NodNum, p = p)
dim(Delta)
dim(X2)
if (ncol(Delta) != ncol(X2)){stop("number of columns of penalty matrix does not equal number of columns of design matrix X")}
#if(lambdaInit <= 0){stop("initial penalty lambdaInit should be larger than zero")}
#if(alphaInit <= 0){stop("initial penalty alphaInit should be larger than zero")}
optPenalties <- optPenaltyGLM.kCVauto2(Y = Y1, X = X2, U = U1,
lambdaInit = optLam1[1], lambdaGinit = 10,
folds = foldsHyp,
Dg=Delta,model = "surv",loss="loglik")
optPenalties
optLam1
Fit = ridgeGLM2(Y = Y1, U = U1, X = X2,
lambda = optPenalties[1], lambdaG = optPenalties[2], Dg = Delta,
model="surv")
names(Fit)<-c(colnames(U1),colnames(X2))
#ids1 = which(colnames(Xte) %in% names(Fit))
#Xte <- Xte[,ids1]
#ids = which(names(Fit) %in% c(colnames(Ute_tree), colnames(Xte)))
#Ests = Fit[ids]
#Ests = Fit
#exp(Ests)[1:5]/(1+exp(Ests)[1:5])
LP = -as.numeric(cbind(Ute_tree,Xte) %*% Fit)
#exp(LP)[1:5]/(1+exp(LP)[1:5])
Concordances[j] <- concordance(Ytest ~ LP)$concordance
Concordances1[j] <- Est.Cval(cbind(Ytest[,1],Ytest[,2],-LP), tau=5, nofit=T)$Dhat
AUCs[j] <- survivalROC.C(Stime = Ytest[,1], status = Ytest[,2], marker = -LP, predict.time = RelTime)$AUC
remove(Fit,ids)
}
Concordances1[j] <- Est.Cval(cbind(Ytest[,1],Ytest[,2],-LP), tau=tau, nofit=T)$Dhat
j=2
EmpNodes = names(pvals)[1:j]
#names(Fits)[i] <- paste(names(pvals)[1:i],collapse = ",")
print(paste("Fit FusedTree without omics effects in", paste(names(pvals)[1:j],collapse = ", ")))
ids = lapply(EmpNodes, function (x) grepl(x,colnames(X1)))
ids1 = which(Reduce("|",ids))
X2 <- X1[,-ids1]
Xte <- Xte_tree[,-ids1]
remove(ids,ids1)
NodNum <- ncol(X2)/p
dim(X2)
gc()
if (NodNum == 0){
Fit <- glm(Y1 ~ 0 + ., data = data.frame(U1),family = "binomial")$coefficients
ids = which(names(Fit) %in% colnames(Ute_tree))
Ests = Fit[ids]
LP <- as.numeric(Ute_tree %*% Ests)
Preds <- exp(LP)/(1+exp(LP))
AUCs[j] <- roc(Yte_tree,Preds)$auc
MSEs[j] <- mean((Preds-Yte_tree)^2)
remove(Fit,ids)
}
if (NodNum == 1){
dim(X2)
Lam <- optPenaltyGLM.kCVauto2(Y = Y1, X = X2, U = U1,
lambdaInit = Lam1, lambdaGinit = 0, Dg = matrix(0, ncol=ncol(X2), nrow = ncol(X2)),
folds = foldsHyp,
model = "surv", loss="loglik")
Fit <-ridgeGLM2(Y = Y1, U = U1, X = X2,
lambda = Lam, lambdaG = 0, Dg = matrix(0, ncol=ncol(X2), nrow = ncol(X2)),
model="surv")
names(Fit)<-c(colnames(U1),colnames(X2))
#exp(Fit[1:5])/(1+exp(Fit[1:5]))
#head(Fit,50)
#ids1 = which(colnames(Xte) %in% names(Fit))
#Xte <- Xte[,ids1]
#ids = which(names(Fit) %in% c(colnames(Ute_tree), colnames(Xte)))
#Ests = Fit[ids]
#Ests = Fit
#remove(ids1,ids,Lam)
LP = -as.numeric(cbind(Ute_tree,Xte) %*% Fit)
Preds <- exp(LP)/(1+exp(LP))
Concordances[j] <- concordance(Yte_tree ~ LP)$concordance
remove(Fit,LP,Preds)
}
if (NodNum > 1){
Delta = .PenMatr(NumNodes = NodNum, p = p)
dim(Delta)
dim(X2)
if (ncol(Delta) != ncol(X2)){stop("number of columns of penalty matrix does not equal number of columns of design matrix X")}
#if(lambdaInit <= 0){stop("initial penalty lambdaInit should be larger than zero")}
#if(alphaInit <= 0){stop("initial penalty alphaInit should be larger than zero")}
optPenalties <- optPenaltyGLM.kCVauto2(Y = Y1, X = X2, U = U1,
lambdaInit = optLam1[1], lambdaGinit = 10,
folds = foldsHyp,
Dg=Delta,model = "surv",loss="loglik")
optPenalties
optLam1
Fit = ridgeGLM2(Y = Y1, U = U1, X = X2,
lambda = optPenalties[1], lambdaG = optPenalties[2], Dg = Delta,
model="surv")
names(Fit)<-c(colnames(U1),colnames(X2))
#ids1 = which(colnames(Xte) %in% names(Fit))
#Xte <- Xte[,ids1]
#ids = which(names(Fit) %in% c(colnames(Ute_tree), colnames(Xte)))
#Ests = Fit[ids]
#Ests = Fit
#exp(Ests)[1:5]/(1+exp(Ests)[1:5])
LP = -as.numeric(cbind(Ute_tree,Xte) %*% Fit)
#exp(LP)[1:5]/(1+exp(LP)[1:5])
Concordances[j] <- concordance(Ytest ~ LP)$concordance
Concordances1[j] <- Est.Cval(cbind(Ytest[,1],Ytest[,2],-LP), tau=tau, nofit=T)$Dhat
AUCs[j] <- survivalROC.C(Stime = Ytest[,1], status = Ytest[,2], marker = -LP, predict.time = RelTime)$AUC
remove(Fit,ids)
}
Delta = .PenMatr(NumNodes = NodNum, p = p)
dim(Delta)
dim(X2)
Dat = Dat_Tree(tree = Treefit, X = X, Y = Y,Z = Z,  LinVars = Lin,model = "surv")
X1 = Dat$Omics; Y1 = Dat$Response; U1 = Dat$Clinical
colSums(U1)
Dat_tree_test = Dat_Tree(tree=Treefit, X=Xtest, Y=Ytest, Z=Ztest, LinVars = Lin,model = "surv")
Ute_tree = Dat_tree_test$Clinical; Yte_tree=Dat_tree_test$Response; Xte_tree = Dat_tree_test$Omics
remove(Dat,Dat_tree_test,Yte_tree)
colSums(Ute_tree)
Concordances <- c()
Concordances1 <- c()
AUCs <- c()
j=2
EmpNodes = names(pvals)[1:j]
#names(Fits)[i] <- paste(names(pvals)[1:i],collapse = ",")
print(paste("Fit FusedTree without omics effects in", paste(names(pvals)[1:j],collapse = ", ")))
ids = lapply(EmpNodes, function (x) grepl(x,colnames(X1)))
ids1 = which(Reduce("|",ids))
NumNod
seq(2,p*NumNod,NumNod)
ids1 = seq(4,p*NumNod,NumNod)
ids = unique(c(ids,ids1))
ids = seq(2,p*NumNod,NumNod)
ids1 = seq(4,p*NumNod,NumNod)
ids = c(ids,ids1)
X2 <- X1[,-ids1]
Xte <- Xte_tree[,-ids1]
remove(ids,ids1)
NodNum <- ncol(X2)/p
dim(X2)
ids = seq(2,p*NumNod,NumNod)
ids1 = seq(4,p*NumNod,NumNod)
ids = c(ids,ids1)
X2 <- X1[,-ids]
Xte <- Xte_tree[,-ids]
remove(ids,ids1)
NodNum <- ncol(X2)/p
dim(X2)
gc()
if (NodNum == 0){
Fit <- glm(Y1 ~ 0 + ., data = data.frame(U1),family = "binomial")$coefficients
ids = which(names(Fit) %in% colnames(Ute_tree))
Ests = Fit[ids]
LP <- as.numeric(Ute_tree %*% Ests)
Preds <- exp(LP)/(1+exp(LP))
AUCs[j] <- roc(Yte_tree,Preds)$auc
MSEs[j] <- mean((Preds-Yte_tree)^2)
remove(Fit,ids)
}
if (NodNum == 1){
dim(X2)
Lam <- optPenaltyGLM.kCVauto2(Y = Y1, X = X2, U = U1,
lambdaInit = Lam1, lambdaGinit = 0, Dg = matrix(0, ncol=ncol(X2), nrow = ncol(X2)),
folds = foldsHyp,
model = "surv", loss="loglik")
Fit <-ridgeGLM2(Y = Y1, U = U1, X = X2,
lambda = Lam, lambdaG = 0, Dg = matrix(0, ncol=ncol(X2), nrow = ncol(X2)),
model="surv")
names(Fit)<-c(colnames(U1),colnames(X2))
#exp(Fit[1:5])/(1+exp(Fit[1:5]))
#head(Fit,50)
#ids1 = which(colnames(Xte) %in% names(Fit))
#Xte <- Xte[,ids1]
#ids = which(names(Fit) %in% c(colnames(Ute_tree), colnames(Xte)))
#Ests = Fit[ids]
#Ests = Fit
#remove(ids1,ids,Lam)
LP = -as.numeric(cbind(Ute_tree,Xte) %*% Fit)
Preds <- exp(LP)/(1+exp(LP))
Concordances[j] <- concordance(Yte_tree ~ LP)$concordance
remove(Fit,LP,Preds)
}
if (NodNum > 1){
Delta = .PenMatr(NumNodes = NodNum, p = p)
dim(Delta)
dim(X2)
if (ncol(Delta) != ncol(X2)){stop("number of columns of penalty matrix does not equal number of columns of design matrix X")}
#if(lambdaInit <= 0){stop("initial penalty lambdaInit should be larger than zero")}
#if(alphaInit <= 0){stop("initial penalty alphaInit should be larger than zero")}
optPenalties <- optPenaltyGLM.kCVauto2(Y = Y1, X = X2, U = U1,
lambdaInit = optLam1[1], lambdaGinit = 10,
folds = foldsHyp,
Dg=Delta,model = "surv",loss="loglik")
optPenalties
optLam1
Fit = ridgeGLM2(Y = Y1, U = U1, X = X2,
lambda = optPenalties[1], lambdaG = optPenalties[2], Dg = Delta,
model="surv")
names(Fit)<-c(colnames(U1),colnames(X2))
#ids1 = which(colnames(Xte) %in% names(Fit))
#Xte <- Xte[,ids1]
#ids = which(names(Fit) %in% c(colnames(Ute_tree), colnames(Xte)))
#Ests = Fit[ids]
#Ests = Fit
#exp(Ests)[1:5]/(1+exp(Ests)[1:5])
LP = -as.numeric(cbind(Ute_tree,Xte) %*% Fit)
#exp(LP)[1:5]/(1+exp(LP)[1:5])
Concordances[j] <- concordance(Ytest ~ LP)$concordance
Concordances1[j] <- Est.Cval(cbind(Ytest[,1],Ytest[,2],-LP), tau=tau, nofit=T)$Dhat
AUCs[j] <- survivalROC.C(Stime = Ytest[,1], status = Ytest[,2], marker = -LP, predict.time = RelTime)$AUC
remove(Fit,ids)
}
remove(X2)
rpart.plot(Treefit, # middle graph
type=5,
extra=1,
box.palette="Pu",
branch.lty=8,
shadow.col="gray",
nn=TRUE)
fold = 2
ids=foldsPerf[[fold]]
X<-GenExpr[-ids,]; Xtest<-GenExpr[ids,]
Y<-Resp[-ids,]; Ytest<-Resp[ids,]
Z<-Clin[-ids,-4]; Ztest=Clin[ids,-4]
Z<-Clin[-ids,]; Ztest=Clin[ids,]
Y<-Resp[-ids,]; Ytest<-Resp[ids,]
load("Metabric.Rdata.")
GenExpr<-scale(GenExpr)
library(survival)
library(survminer)
library(survC1)
library(rpart);
library(rpart.plot)
library(treeClust)
library(multiridge)
library(penalized)
library(glmnet)
library(globaltest)
library(randomForestSRC)
library(blockForest)
library(gbm)
library(SurvMetrics)
library(survivalROC)
fit <- survfit(Resp ~ 1, data = Clin)
sum(fit$n.event)
ggsurvplot(fit, data = Clin, palette =  "jco")$plot
fold = 2
ids=foldsPerf[[fold]]
X<-GenExpr[-ids,]; Xtest<-GenExpr[ids,]
Y<-Resp[-ids,]; Ytest<-Resp[ids,]
View(Clin)
Z<-Clin[-ids,-4]; Ztest=Clin[ids,-4]
p_clin = ncol(model.matrix(~.,Z)[,-1])
p = ncol(X)
Lin = T
RelTime = 10*365
tau = 7500
# 0. Clinical
ClinFit <- coxph(Y ~.,data = Z)
summary(ClinFit)
LpPred = -predict(ClinFit,newdata = Ztest,type = "lp")
ConcClin <- concordance(Ytest ~ LpPred)$concordance
ConcClin1 <- Est.Cval(cbind(Ytest[,1],Ytest[,2],-LpPred), tau = tau,  nofit=T)$Dhat
AUCClin <- survivalROC.C(Stime = Ytest[,1], status = Ytest[,2], marker = -LpPred, predict.time = RelTime)$AUC
remove(ClinFit,LpPred)
#1. RF
DFtrain <- cbind.data.frame(time=Y[,1], event=Y[,2],X,Z)
DFtest <- cbind.data.frame(time=Ytest[,1],event=Ytest[,2],Xtest,Ztest)
RF <- rfsrc(Surv(time,event) ~ .,data=DFtrain,ntree=2000, var.used="all.trees",importance=c("none"),splitrule="logrank",
mtry = 4*sqrt(p))
preds_RF <- predict.rfsrc(RF, newdata = DFtest, outcome = "train")
ConcRF <- 1-preds_RF$err.rate[2000]
ConcRF1 <-  Est.Cval(cbind(Ytest[,1],Ytest[,2],rowSums(preds_RF$chf)), tau = tau, nofit=T)$Dhat
AUCRF <- survivalROC.C(Stime = Ytest[,1], status = Ytest[,2], marker = rowSums(preds_RF$chf), predict.time = RelTime)$AUC
remove(DFtrain,DFtest,preds_RF,RF)
setwd("C:/Users/VNOB-0732/Desktop/R files/ClinOmics/Applications")
source('Sidefunctions_Update.R')
source('RidgeFunctions_Update.R')
#2. Ridge
foldsHyp <- CVfolds(Y=Y, model = "cox", kfold = 5,nrepeat = 3)
start=proc.time()
Lam1=optPenaltyGLM.kCVauto2(Y = Y, X = X, U = model.matrix(~0+., Z),
lambdaInit = 10000,
lambdaGinit = 0, maxIter = 100, minSuccDiff = 1e-5,
model = "surv", folds = foldsHyp, loss = "loglik")
end=proc.time()-start
end
RidgeFit <- ridgeGLM2(Y = Y, U = model.matrix(~0+., Z), X = X,
lambda = Lam1, lambdaG = 0, Dg = matrix(0, ncol=ncol(X), nrow = ncol(X)),
model="surv")
LP = (cbind(model.matrix(~0+., Ztest),Xtest) %*% RidgeFit)[,1]
LP1 = -LP
ConcRidge <- concordance(Ytest ~ LP1)$concordance
ConcRidge1 <- Est.Cval(cbind(Ytest[,1],Ytest[,2],LP), tau = tau, nofit=T)$Dhat
AUCRidge <- survivalROC.C(Stime = Ytest[,1], status = Ytest[,2], marker = LP, predict.time = RelTime)$AUC
Las = cv.glmnet(cbind(model.matrix(~0+.,Z)[,-1],X),Y, alpha = 1, nfolds = 5,family = "cox",
penalty.factor = c(rep(0,p_clin),rep(1,p)))$lambda.min
LassoFit = glmnet(cbind(model.matrix(~0+.,Z)[,-1],X),Y, alpha = 1, lambda = Las, family = "cox",
penalty.factor = c(rep(0,p_clin),rep(1,p)))
LP = -(cbind(model.matrix(~0+., Ztest)[,-1],Xtest) %*% LassoFit$beta)[,1]
ConcLasso <- concordance(Ytest ~ LP)$concordance
ConcLasso1 <- Est.Cval(cbind(Ytest[,1],Ytest[,2],-LP), tau = tau, nofit=T)$Dhat
AUCLasso <- survivalROC.C(Stime = Ytest[,1], status = Ytest[,2], marker = -LP, predict.time = RelTime)$AUC
remove(LassoFit,LP)
gc()
### boosting ###
DFtrain <- cbind.data.frame(time=Y[,1], event=Y[,2],X,Z)
DFtest <- cbind.data.frame(time=Ytest[,1],event=Ytest[,2],Xtest,Ztest)
gc()
set.seed(97)
gbm <- gbm(Surv(time, event)~.,
DFtrain,
n.trees = 200,
interaction.depth=2,
distribution="coxph")
set.seed(97)
gbm.pred <- predict.gbm(gbm,
newdata=DFtest,
type="response")
gbm.pred <- -gbm.pred
ConcGB <- concordance(Ytest ~ gbm.pred)$concordance
ConcGB1 <- Est.Cval(cbind(Ytest[,1],Ytest[,2],-gbm.pred), tau = tau, nofit=T)$Dhat
AUCGB <- survivalROC.C(Stime = Ytest[,1], status = Ytest[,2], marker = -gbm.pred, predict.time = RelTime)$AUC
remove(DFtrain,DFtest,gbm,gbm.pred)
#### BlockForest ####
#####################
gc()
Xblock = cbind.data.frame(Z,X)
XblockTest = cbind.data.frame(Ztest,Xtest)
colnames(Xblock) <- paste("X", 1:ncol(Xblock), sep="")
colnames(XblockTest) <- paste("X", 1:ncol(XblockTest), sep="")
blocks <- rep(1:2, times=c(ncol(Z), ncol(X)))
blocks <- lapply(1:2, function(x) which(blocks==x))
#blocks[[2]]
set.seed(43)
blockforobj <- blockfor(Xblock, Y,  replace = TRUE, blocks=blocks,
nsets = 50)
blockforobj$paramvalues
set.seed(43)
Preds=predict(blockforobj$forest, data=XblockTest)
Preds <- -rowSums(Preds$chf)
#Preds <- apply(Preds$survival,1,median)
ConcBlock <- concordance(Ytest ~ Preds)$concordance
ConcBlock1 <- Est.Cval(cbind(Ytest[,1],Ytest[,2],-Preds), tau = tau, nofit=T)$Dhat
AUCBlock <- survivalROC.C(Stime = Ytest[,1], status = Ytest[,2], marker = -Preds, predict.time = RelTime)$AUC
remove(Xblock,XblockTest,blocks,Preds,blockforobj)
dat=cbind.data.frame(Y,Z)
set.seed(9)
rp <- rpart(Y~.,data = dat, control = rpart.control(xval =5, minbucket = 50,cp=0),
model = T)
minerr <- which.min(rp$cptable[,"xerror"])
bestcp <- rp$cptable[minerr,"CP"]
remove(minerr)
Treefit <- prune(rp, cp = bestcp)
rpart.plot(Treefit, # middle graph
type=5,
extra=1,
box.palette="Pu",
branch.lty=8,
shadow.col="gray",
nn=TRUE)
Nodes <-  row.names(Treefit$frame)[rpart.predict.leaves(Treefit,Z)]
Nodes <- as.numeric(Nodes)
NumNod <- length(unique(Nodes))
gc()#Lam1=1000
optLam1 = PenOpt(Tree=Treefit,Y=Y,X=X,Z=Z,model = "surv",lambdaInit = 100,alphaInit = 10,
folds = foldsHyp,LinVars = Lin, maxIter = 30)
optLam1
Fit=FusTreeFit(Tree=Treefit,Y=Y,X=as.matrix(X),Z=Z,model = "surv",lambda = optLam1[1],alpha =  optLam1[2],LinVars = Lin)
Preds=Predictions(fit=Fit,newX = as.matrix(Xtest),newZ = Ztest,newY = Ytest, model="surv", Linvars = Lin)
Preds = Preds$Preds
lpmin=-as.numeric(Preds$LinPred)
Resp=Preds$Resp
optLam1
ConcFusTree=concordance(Ytest ~ lpmin)$concordance
ConcFusTree1=Est.Cval(cbind(Ytest[,1],Ytest[,2],-lpmin), tau=tau, nofit=T)$Dhat
AUCFusTree <- survivalROC.C(Stime = Ytest[,1], status = Ytest[,2], marker = -lpmin, predict.time = RelTime)$AUC
Fit$Effects[1:4]
